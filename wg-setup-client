#!/bin/bash
# Generate a WireGuard configuration for wg-quick or
# systemd-networkd, if it's the active network manager.
# Meant to easily setup large amounts of clients to a network by just
# providing individual IP addresses
# This is not sophisticated, but meant to customize or just inspire. Have fun.
#   created by Eicke Herbertz, 2020

set -eu

error() {
    echo "Error: $*" >&2
    exit 1
}

has-systemd() {
    command -v systemctl >/dev/null
}

systemd-booted() {
    [[ -d /run/systemd/system ]]
}

usage() {
    cat <<EOF
Usage: $0 [-fhst] [-d descr] [-e <endpoint>] [-i <name>] [-p pubkey]
        [ip-addr] [port (with -s)]

    -b,--backend    Backend to configure (networkd, wg-quick or auto (default))
    -d,--descr      Description for .netdev (default: WireGuard VPN)
    -e,--endpoint   WireGuard endpoint of the Server
    -f,--force      overwrite existing files
    -h,--help       Show this usage text
    -i,--iface      name of the WireGuard interface to create (default: wg0)
    -p,--pubkey     WireGuard public key of the Server
    -s,--server     Create a server configuration (skip peer setup)
    ip-addr         ip address for this client
    port            listening port in --server mode
EOF
    exit $1
}

# Adapted from https://stackoverflow.com/a/32690695/2208453
ip2int() {
    local a b c d
    { IFS=. read a b c d; } <<< $1
    echo $(( ( ( ( ( (a << 8) | b) << 8) | c) << 8) | d))
}

int2ip() {
    local ui32=$1 ip n
    for n in 0 8 16 24; do
        ip=$(((ui32 & 0xff << $n) >> $n))${ip:+.${ip}}
    done
    echo $ip
}

network() {
    local addr="$(ip2int $1)"
    local mask="$((0xffffffff << (32 - $2)))"
    int2ip $((addr & mask))
}

networkd_network_header() {
    local ifname=$1
    cat <<EOF
[Match]
Name = ${ifname}

[Network]
EOF
}

networkd_netdev_header() {
    local ifname="$1"
    local desc="$2"
    cat <<EOF
[NetDev]
Name = ${ifname}
Kind = wireguard
Description = ${desc}

[WireGuard]
EOF
}

wg_quick_conf_header() {
    local ifname="$1"
    local desc="$2"
    cat <<EOF
# ${ifname}: ${desc}
[Interface]
EOF
}

command -v wg >/dev/null || error "wg not found. Please install wireguard-tools first!"

OPTS=d:e:fhi:p:s
LOPTS=descr:,endpoint:,force,help,iface:,pubkey:,server
PARSED_OPTS=$(getopt -o $OPTS -l $LOPTS -n "$0" -- "$@")
eval set -- "$PARSED_OPTS"

WG_DESC="WireGuard VPN"
WG_ENDPOINT=
BACKEND=auto
FORCE=
WG_IFNAME=wg0
WG_PUBLIC_KEY=
CREATE_SERVER=
IP_ADDRESS=
SERVER_PORT=

while [[ "$1" != "--" ]]; do
    case $1 in
    -b|--backend)
        BACKEND="$2"
        shift 2
        ;;
    -d|--descr)
        WG_DESC="$2"
        shift 2
        ;;
    -e|--endpoint)
        WG_ENDPOINT="$2"
        shift 2
        ;;
    -f|--force)
        FORCE=yes
        shift
        ;;
    -h|--help)
        usage
        ;;
    -i|--iface)
        WG_IFNAME="$2"
        shift 2
        ;;
    -p|--pubkey)
        WG_PUBLIC_KEY="$2"
        shift 2
        ;;
    -s|--server)
        CREATE_SERVER=yes
        shift
        ;;
    *)
        echo "Programming error" >&2
        usage 1
        ;;
    esac
done
shift # away the --

# All positional arguments are optional. Client setup accepts one, server setup two values.
[[ $# -ge 1 ]] && IP_ADDRESS="$1"
[[ $# -ge 2 ]] && SERVER_PORT="$2"
[[ $# -ge 3 ]] && usage 1
# Fail when client setup is called with a second positional.
[[ ! ${CREATE_SERVER} && -n "${SERVER_PORT}" ]] && usage 1

# Ensure WG_TEST is defined
WG_TEST=${WG_TEST:-}

# Check that we are running as root or testing (TODO: have an actual test suite)
[[ $UID -eq 0 || -n "${WG_TEST}" ]] || error "Please run as root!"

# Now read all required parameters that weren't provided as arguments interactively

# The IP address is required for both server and client
if [[ -z "${IP_ADDRESS}" ]]; then
    [[ ${CREATE_SERVER} ]] && \
        echo -n "Enter server ip address: " || \
        echo -n "Enter ip address for this client: "
    read -r IP_ADDRESS
fi

[[ "${IP_ADDRESS}" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}(/[0-9]{1,2})?$ ]] || error "Invalid ip address"

# Then, read the listening port for a server or a serverÂ´s public key and endpoint for a client
if [[ ${CREATE_SERVER} ]]; then
    if [[ -z "${SERVER_PORT}" ]]; then
        echo -n "Enter server listening port (empty: random port): "
        read -r SERVER_PORT
    fi

    [[ "${SERVER_PORT}" =~ ^[0-9]{1,5}$ ]] || error "Invalid port"
else
    if [[ -z "${WG_PUBLIC_KEY}" ]]; then
        echo -n "Server PublicKey: "
        read -r WG_PUBLIC_KEY
    fi

    [[ "${WG_PUBLIC_KEY}" =~ ^[A-Za-z0-9/+]{43}=$ ]] || error "Invalid PublicKey format!"

    if [[ -z "${WG_ENDPOINT}" ]]; then
        echo -n "Server Endpoint: "
        read -r WG_ENDPOINT
    fi

    [[ "${WG_ENDPOINT}" =~ ^[A-Za-z0-9.-]+:[0-9]+$ ]] || error "Invalid Endpoint (host:port)!"
fi

# If subnet is provided on ip address use it
if [[ "${IP_ADDRESS%/*}" != "${IP_ADDRESS}" ]]; then
    IP_NETMASK="${IP_ADDRESS#*/}"
    IP_ADDRESS="${IP_ADDRESS%/*}"
    [[ "${IP_NETMASK}" =~ ^[0-9]{2}$ ]] || error "Invalid subnet length ${IP_NETMASK}"
else
    echo "Warning: No subnet lenght provided, using /24!"
    IP_NETMASK=24
fi

# Calculate network from IP address and subnet length
network_addr=$(network "${IP_ADDRESS}" "${IP_NETMASK}")

# Check parsed result (TODO: write tests for the conversion and not check here)
[[ "${network_addr}" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] ||
    error "Failed to calculate network address (Result: ${network_addr})"

# TODO: make this configurable
WG_ALLOWED_IPS="${network_addr}/${IP_NETMASK}"

# If backend is set to auto, check which one to use
if [[ "$BACKEND" == "auto" ]]; then
    if has-systemd && systemctl is-enabled systemd-networkd.service >/dev/null; then
        BACKEND=networkd
    else
        BACKEND=wg-quick
    fi
fi

# Setup the selected backend. The code further below will not use the $BACKEND variable directly,
# but the WG_QUICK_CONF, WG_NETDEV and WG_NETWORK variables defined here.
# It is possible to predefine these variables in the environment and use custom paths.
case "$BACKEND" in
    networkd)
        echo "Using systemd-networkd for configuration"
        unset WG_QUICK_CONF

        WG_BASENAME=${WG_BASENAME:-90-wireguard}
        WG_NETDEV=${WG_NETDEV:-/etc/systemd/network/${WG_BASENAME}.netdev}
        WG_NETWORK=${WG_NETWORK:-/etc/systemd/network/${WG_BASENAME}.network}

        [[ -f "${WG_NETDEV}" && -z "${FORCE}" ]] &&
            error "${WG_NETDEV} already exists (use -f to overwrite)!"
        [[ -f "${WG_NETWORK}" && -z "${FORCE}" ]] &&
            error "${WG_NETWORK} already exists (use -f to overwrite)!"
        ;;
    wg-quick)
        echo "Using wg-quick for configuration"
        unset WG_NETDEV WG_NETWORK

        WG_QUICK_CONF=${WG_QUICK_CONF:-/etc/wireguard/${WG_IFNAME}.conf}

        [[ -f "${WG_QUICK_CONF}" && -z "${FORCE}" ]] &&
            error "${WG_QUICK_CONF} already exists (use -f to overwrite)!"
        ;;
    *)
        error "Unknown backend ${BACKEND}!"
        ;;
esac

# The networkd configuration is split into a .network and a .netdev file, while wg-quick has only one.
if [[ ${WG_NETWORK:-} ]]; then
    networkd_network_header "${WG_IFNAME}" > "${WG_NETWORK}"
    networkd_netdev_header "${WG_IFNAME}" "${WG_DESC}" > "${WG_NETDEV}"
else
    wg_quick_conf_header "${WG_IFNAME}" "${WG_DESC}" > "${WG_QUICK_CONF}"
fi

# The configuration keys and format of networkd and wg-quick are identical, only the
# sections have different names. So we can use the same code for both.
WG_CONF_TARGET="${WG_QUICK_CONF:-${WG_NETDEV}}"

# This will write an empty value if no SERVER_PORT is provided. If we bring the interface
# up successfully, the actual port will be set later in the script.
[[ ${CREATE_SERVER} ]] && echo "ListenPort = ${SERVER_PORT}" >> "${WG_CONF_TARGET}"

# Generate and write the private key. We'll only keep the public key to print out at the end.
PRIVATE_KEY="$(wg genkey)"
PUBLIC_KEY="$(wg pubkey <<<${PRIVATE_KEY})"
echo "PrivateKey = ${PRIVATE_KEY}" >> "${WG_CONF_TARGET}"
unset PRIVATE_KEY

# Only the IP address goes into the network file when using systemd-networkd
echo "Address = ${IP_ADDRESS}/${IP_NETMASK}" >> "${WG_QUICK_CONF:-${WG_NETWORK}}"

# Add a blank line before peer configuration
echo >> "${WG_CONF_TARGET}"

# If configuring a client, write the server peer configuration
[[ ! ${CREATE_SERVER} ]] && cat >> "${WG_CONF_TARGET}" <<EOF
[${WG_NETDEV:+WireGuard}Peer]
PublicKey = ${WG_PUBLIC_KEY}
AllowedIPs = ${WG_ALLOWED_IPS}
Endpoint = ${WG_ENDPOINT}
PersistentKeepalive = 25

EOF

# Set permissions and ownership of the new files
chmod 0640 "${WG_CONF_TARGET}"
[[ -n "${WG_NETDEV:-}" && -z "${WG_TEST}" ]] && chgrp systemd-network "${WG_NETDEV}"

# Select which service to enable and (re)start
if [[ -z "${WG_QUICK_CONF:-}" ]]; then
    SERVICE="systemd-networkd.service"
else
    SERVICE="wg-quick@${WG_IFNAME}.service"
fi

# Enable the service if we have systemd
if [[ ! ${WG_TEST} ]] && has-systemd; then
    systemctl enable "${SERVICE}"
fi

# Check for wireguard module and try to bring up the interface
if ! lsmod | grep ^wireguard >/dev/null && ! modprobe wireguard; then
    echo "Can't load WireGuard module! Probably the kernel got updated, please reboot!" >&2
    if [[ ${CREATE_SERVER} && -z "${SERVER_PORT}" ]]; then
        echo "Could not start server and no port was set!" >&2
        echo "You will have to set the ListenPort manually in ${WG_CONF_TARGET}" >&2
    fi
else
    if [[ ${WG_TEST} ]]; then
        echo "Testing: Skipping (re)starting ${SERVICE}."
    elif has-systemd && systemd-booted; then
        echo "(Re)starting ${SERVICE}"
        systemctl restart "${SERVICE}"
    elif has-systemd; then
        echo "systemd not booted, skipping (re)starting ${SERVICE}."
    else
        echo "Installing without systemd: Running wg-quick up ${WG_IFNAME}"
        if ! wg-quick up ${WG_IFNAME}; then
            echo "Couldn't start WireGuard interface! If running in a container, probably CAP_NET_ADMIN is missing." >&2
        fi
    fi

    # If we are setting up a server and had no listening port provided, WireGuard will select a
    # random port which we'll extract and write it to the configuration to make it persistent.
    if [[ ${CREATE_SERVER} && -z "${SERVER_PORT}" ]]; then
        SERVER_PORT=$(wg show "${WG_IFNAME}" | awk '/listening port/{print $3}')
        if [[ -z "${SERVER_PORT}" ]]; then
            echo "Warning: Could not determine ListenPort!" >&2
            echo "You will have to set the ListenPort manually in ${WG_CONF_TARGET}" >&2
        else
            sed -i "s/ListenPort = /ListenPort = ${SERVER_PORT}/" "${WG_CONF_TARGET}"
        fi
    fi
fi

if [[ ! ${CREATE_SERVER} ]]; then
    echo "============================================================
WireGuard setup successful! Server side add-peer command:
wg-setup add-peer ${HOSTNAME} ${PUBLIC_KEY} ${IP_ADDRESS}"
    exit 0
else
    echo "============================================================
WireGuard server setup successful!
PublicKey: ${PUBLIC_KEY}
ListenPort: ${SERVER_PORT}"
    exit 0
fi
